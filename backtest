# taiex_alpha_backtest.py
# 僅讀老師資料包 RESULT_fut_gap_fixed_2017-2023.zip
# 成本 = 單邊 |Δpos| × 價格 × 0.0002（以權益近似為 |Δpos| × COST_RATE × equity）
# 正常版：一次全掃 Grid 18,432 → Stage-1 粗篩 → Stage-2 WF 打分 → 產出 PPT

import os, io, json, zipfile, warnings, datetime as dt, sys
import numpy as np
import pandas as pd

warnings.filterwarnings("ignore", category=FutureWarning)
pd.options.mode.chained_assignment = None

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

from pptx import Presentation
from pptx.util import Inches, Pt

try:
    from tqdm import tqdm
except Exception:
    def tqdm(x, **k): return x

# ========= 常數 =========
TEACHER_ZIP  = "RESULT_fut_gap_fixed_2017-2023.zip"
INIT_EQUITY  = 100000.0
COST_RATE    = 0.0002
TRADING_DAYS = 252
MOM_N        = 10  # 10日動能

# Walk-Forward（穩健）
WF_TRAIN_M = 24
WF_TEST_M  = 6
WF_STEP_M  = 6
WF_SPLITS  = 10

# Grid（8*8*6*4*2*2*3 = 18,432）
GRID = dict(
    vol_lb            = [15,20,30,40,60,90,120,180],               # 8
    vol_target        = [0.10,0.12,0.15,0.18,0.20,0.25,0.30,0.35], # 8
    lev_cap           = [2,3,4,6,8,12],                             # 6
    rebalance_days    = [1,2,3,5],                                  # 4
    smooth_days       = [1,2],                                      # 2
    trend_filter_mode = ["off","soft"],                             # 2
    ma_long           = [120,180,240],                              # 3
)

REQUIRED_KEYS = ("vol_lb","vol_target","lev_cap","rebalance_days","smooth_days","trend_filter_mode","ma_long")

# ========= 小工具 =========
def _pick_by_exact_or_substr(cols, candidates, required=True, what=""):
    cl = [str(c).strip() for c in cols]
    low = [c.lower() for c in cl]
    for cand in candidates:
        if cand in low: return cl[low.index(cand)]
    for cand in candidates:
        cc = cand.replace("_","").replace(" ","")
        for i, l in enumerate(low):
            if cc in l.replace("_","").replace(" ",""):
                return cl[i]
    if required:
        raise ValueError(f"資料需含 {what or candidates} 欄位之一")
    return None

# ========= 讀老師資料包 =========
def read_teacher_bundle() -> pd.DataFrame:
    assert os.path.exists(TEACHER_ZIP), f"找不到老師資料包：{TEACHER_ZIP}"
    with zipfile.ZipFile(TEACHER_ZIP, "r") as zf:
        names = zf.namelist()
        fea = next((n for n in names if n.lower().endswith(".feather")), None)
        csv = next((n for n in names if n.lower().endswith(".csv")), None)
        if fea is None and csv is None:
            raise ValueError("資料包內找不到 feather 或 csv")

        if fea is not None:
            try:
                import pyarrow.feather as feather
            except Exception:
                raise ImportError("ZIP 內是 feather，但環境缺 pyarrow；請安裝 pyarrow 或改用含 csv 的資料包")
            with zf.open(fea) as f:
                buf = io.BytesIO(f.read())
            df = feather.read_feather(buf)
        else:
            with zf.open(csv) as f:
                raw = f.read()
            df = None
            for enc in ("utf-8","utf-8-sig","cp950"):
                try:
                    df = pd.read_csv(io.BytesIO(raw), encoding=enc)
                    break
                except Exception:
                    df = None
            if df is None:
                raise ValueError("ZIP 內 CSV 讀取失敗，請確認編碼")

    df = df.copy()
    df.columns = [str(c).strip() for c in df.columns]
    date_col  = _pick_by_exact_or_substr(df.columns,
                 ["date","datetime","ts","time","交易日期","日期","trade_date"], True, "日期")
    close_col = _pick_by_exact_or_substr(df.columns,
                 ["close","c","last","px_last","price","收盤價","成交價","收盤","結算價",
                  "settle","settlement","closeprice","close_price","pxlast"], True, "收盤/結算價")

    df = df.rename(columns={date_col:"date", close_col:"close"})
    df["date"]  = pd.to_datetime(df["date"], errors="coerce").dt.tz_localize(None).dt.normalize()
    df["close"] = pd.to_numeric(df["close"], errors="coerce")
    df = df.dropna(subset=["date","close"]).sort_values("date").drop_duplicates("date").reset_index(drop=True)
    df = df[(df["date"] >= "2017-01-01") & (df["date"] <= "2023-12-31")].copy()
    df = df.set_index("date")
    df["ret"] = df["close"].pct_change().fillna(0.0)
    print(f"[INFO] 僅使用老師資料包 | 來源：{TEACHER_ZIP} | 天數：{len(df):,}")
    return df

# ========= 指標 =========
def drawdown_curve(equity: pd.Series):
    peak = equity.cummax()
    dd = equity/peak - 1.0
    return dd, float(dd.min())

def cagr_from_equity(equity: pd.Series):
    if len(equity) < 2: return np.nan
    eq0, eqT = float(equity.iloc[0]), float(equity.iloc[-1])
    if eq0 <= 0 or eqT <= 0: return np.nan
    years = (equity.index[-1] - equity.index[0]).days / 365.25
    if years <= 0: return np.nan
    return (eqT/eq0)**(1/years) - 1.0

def sharpe(returns: pd.Series):
    s = returns.std(ddof=0)
    return 0.0 if s==0 else returns.mean()/s*np.sqrt(TRADING_DAYS)

def sortino(returns: pd.Series):
    dn = returns.copy(); dn[dn>0]=0.0
    s = dn.std(ddof=0)
    return 0.0 if s==0 else returns.mean()/s*np.sqrt(TRADING_DAYS)

def profit_factor(returns: pd.Series):
    g = returns[returns>0].sum()
    l = -returns[returns<0].sum()
    return np.nan if l==0 else g/l

def up_down_capture(strat_ret: pd.Series, bench_ret: pd.Series):
    df = pd.DataFrame({"s":strat_ret, "b":bench_ret}).dropna()
    if df.empty: return np.nan, np.nan
    m = df.resample("ME").sum()
    up = m[m["b"]>0]; dn = m[m["b"]<0]
    up_cap = np.nan if up["b"].sum()==0 else up["s"].sum()/up["b"].sum()
    dn_cap = np.nan if dn["b"].sum()==0 else dn["s"].sum()/dn["b"].sum()  # 修正：dn["s"]
    return float(up_cap), float(dn_cap)

def cvar_es(returns: pd.Series, alpha=0.95):
    if len(returns)==0: return np.nan
    q = returns.quantile(1-alpha)
    tail = returns[returns<=q]
    if tail.empty: return np.nan
    return float(tail.mean())

def metrics_from_series(equity: pd.Series, strat_ret: pd.Series, bench_ret: pd.Series,
                        trades: int, winrate: float, turnover_mean: float):
    dd, mdd = drawdown_curve(equity)
    k = {}
    k["initial_equity"] = float(equity.iloc[0])
    k["terminal_equity"] = float(equity.iloc[-1])
    k["total_return"]   = k["terminal_equity"]/k["initial_equity"] - 1.0
    k["cagr"]           = cagr_from_equity(equity)
    k["ann_vol"]        = float(strat_ret.std(ddof=0)*np.sqrt(TRADING_DAYS))
    k["sharpe"]         = float(sharpe(strat_ret))
    k["sortino"]        = float(sortino(strat_ret))
    k["calmar"]         = 0.0 if mdd==0 else (0.0 if pd.isna(k["cagr"]) else k["cagr"]/abs(mdd))
    k["max_drawdown"]   = float(mdd)
    k["profit_factor"]  = float(profit_factor(strat_ret))
    up_cap, dn_cap      = up_down_capture(strat_ret, bench_ret)
    k["up_capture"]     = up_cap
    k["down_capture"]   = dn_cap
    k["cvar_95"]        = cvar_es(strat_ret, 0.95)
    k["n_trades"]       = int(trades)
    k["win_rate"]       = float(winrate)
    k["turnover_mean"]  = float(turnover_mean) if turnover_mean is not None else np.nan
    return k

# ========= 策略 =========
def run_strategy(df: pd.DataFrame, cfg: dict):
    for k in REQUIRED_KEYS:
        assert k in cfg, f"Config 缺少鍵：{k}"

    price = df["close"].astype(float)
    ret   = price.pct_change().fillna(0.0)
    bm_ret= ret.copy()

    # 10日動能（t 判斷，t+1 持有）
    mom = price.pct_change(MOM_N)

    # 長均線濾網
    ma = price.rolling(int(cfg["ma_long"]), min_periods=int(cfg["ma_long"])).mean()
    trend_on = (price > ma).astype(float)
    if str(cfg["trend_filter_mode"]).lower() == "off":
        trend_mult = 1.0
    else:  # "soft"
        trend_mult = 0.5 + 0.5*trend_on

    # 波動估計（年化）與槓桿
    vol = ret.rolling(int(cfg["vol_lb"]), min_periods=int(cfg["vol_lb"])).std()*np.sqrt(TRADING_DAYS)
    raw_lev = float(cfg["vol_target"]) / (vol + 1e-12)
    lev = raw_lev.clip(upper=float(cfg["lev_cap"])).fillna(0.0)
    lev = lev * (trend_mult if isinstance(trend_mult, pd.Series) else float(trend_mult))

    # 平滑
    if int(cfg["smooth_days"]) > 1:
        lev = lev.rolling(int(cfg["smooth_days"]), min_periods=1).mean()

    # 只在動能>0 時持倉（做多），不做空
    pos = (mom > 0).astype(float) * lev

    # 再平衡
    step = int(cfg["rebalance_days"])
    if step > 1:
        keep = pos.copy()
        for i in range(1, step):
            keep.iloc[i::step] = np.nan
        pos = keep.ffill().fillna(0.0)

    # 週轉（|Δpos|）
    dpos = pos.diff().abs().fillna(pos.abs())
    turnover_mean = float(dpos.mean())

    # 模擬：Post-Cost & Pre-Cost
    equity_post = pd.Series(np.nan, index=pos.index, dtype=float)
    equity_pre  = pd.Series(np.nan, index=pos.index, dtype=float)
    equity_post.iloc[0] = INIT_EQUITY
    equity_pre.iloc[0]  = INIT_EQUITY
    strat_ret_post = pd.Series(0.0, index=pos.index, dtype=float)
    strat_ret_pre  = pd.Series(0.0, index=pos.index, dtype=float)

    for i in range(1, len(pos)):
        # pre（無交易成本）
        pnl_pre = pos.iloc[i-1] * ret.iloc[i] * equity_pre.iloc[i-1]
        equity_pre.iloc[i] = equity_pre.iloc[i-1] + pnl_pre
        strat_ret_pre.iloc[i] = equity_pre.iloc[i]/equity_pre.iloc[i-1] - 1.0

        # post（含成本）
        trade_cost = dpos.iloc[i] * COST_RATE * equity_post.iloc[i-1]
        pnl_post = pos.iloc[i-1] * ret.iloc[i] * equity_post.iloc[i-1]
        equity_post.iloc[i] = equity_post.iloc[i-1] + pnl_post - trade_cost
        strat_ret_post.iloc[i] = equity_post.iloc[i]/equity_post.iloc[i-1] - 1.0

    bench = INIT_EQUITY * (1.0 + bm_ret).cumprod()

    # 交易次數／勝率（以換倉事件近似）
    trade_mask = dpos > 1e-12
    trades = int(trade_mask.sum())
    wins = int(((pos.shift(1).fillna(0.0)*ret) > 0)[trade_mask].sum())
    winrate = 0.0 if trades==0 else wins/trades

    kpi = metrics_from_series(equity_post, strat_ret_post, bench.pct_change().fillna(0.0),
                              trades, winrate, turnover_mean)
    track = pd.DataFrame({"equity": equity_post, "equity_pre": equity_pre, "bench": bench})
    return kpi, track, strat_ret_post, bench.pct_change().fillna(0.0), dpos, pos

# ========= WF 分段（用於 Stage-2） =========
def wf_splits(df: pd.DataFrame, n_splits=WF_SPLITS, train_m=WF_TRAIN_M, test_m=WF_TEST_M, step_m=WF_STEP_M):
    sidx = df.index
    start = pd.Timestamp(sidx.min()).replace(day=1)
    end   = pd.Timestamp(sidx.max())
    starts = []
    cur = start
    while cur + pd.offsets.MonthEnd(train_m + test_m) <= end:
        starts.append(cur); cur += pd.offsets.MonthEnd(step_m)
    starts = starts[:n_splits]
    for st in starts:
        tr_start = st
        tr_end   = st + pd.offsets.MonthEnd(train_m)
        te_end   = tr_end + pd.offsets.MonthEnd(test_m)
        tr = df[(sidx>=tr_start) & (sidx<=tr_end)].copy()
        te = df[(sidx>tr_end)   & (sidx<=te_end)].copy()
        yield tr, te

# ========= 打分 =========
def pass_stage1(k):
    return (not pd.isna(k["cagr"]) and k["cagr"] > 0) and (abs(k["max_drawdown"]) < 0.80) and (k["n_trades"] >= 12)

def score_from_kpi(k):
    def clip(v, lo, hi):
        if pd.isna(v): return 0.0
        return max(lo, min(hi, v))
    sharpe_n  = clip(k.get("sharpe",0),  -1, 3)/3.0
    sortino_n = clip(k.get("sortino",0), -1, 5)/5.0
    calmar_n  = clip(k.get("calmar",0),   0, 5)/5.0
    cagr_n    = clip(k.get("cagr",0),     0, 0.5)/0.5
    dc        = 1.0 if pd.isna(k.get("down_capture")) else k["down_capture"]
    dc_term   = max(0, min(1.5, 1.0 - dc))/1.5
    S = 0.30*sharpe_n + 0.25*sortino_n + 0.25*calmar_n + 0.10*cagr_n + 0.10*dc_term
    return float(S)

# ========= 繪圖 =========
def plot_equity(track: pd.DataFrame, out_png: str):
    fig, ax = plt.subplots(figsize=(10,4))
    ax.plot(track.index, track["equity"], label="Strategy")
    ax.plot(track.index, track["bench"],  label="Benchmark")
    ax.set_title("Equity Curve (Best Config)")
    ax.set_xlabel("Date"); ax.set_ylabel("Equity")
    ax.legend(); ax.grid(True, alpha=0.3)
    fig.tight_layout(); fig.savefig(out_png, dpi=150); plt.close(fig)
    return out_png

def plot_panel(daily_df: pd.DataFrame, track: pd.DataFrame, kpi: dict,
               turnover_series: pd.Series, pos_series: pd.Series, out_png: str):
    fig = plt.figure(figsize=(12,7))
    gs = fig.add_gridspec(2,3)

    # 1) PnL
    ax = fig.add_subplot(gs[0,0])
    ax.plot(track.index, track["equity"]/INIT_EQUITY, lw=1.2)
    ax.set_title(f"PnL  Sharpe={kpi.get('sharpe',0):.2f}")
    ax.grid(True, alpha=0.3)

    # 2) Post vs Pre 成本
    ax2 = fig.add_subplot(gs[0,1])
    ax2.plot(track.index, track["equity"]/INIT_EQUITY, label="Post-Cost")
    ax2.plot(track.index, track["equity_pre"]/INIT_EQUITY, label="Pre-Cost", alpha=0.8)
    ax2.legend(loc="best"); ax2.grid(True, alpha=0.3)
    ax2.set_title("Post-Cost vs Pre-Cost")

    # 3) Comparable（策略 vs 基準 vs 相對）
    ax3 = fig.add_subplot(gs[0,2])
    eq_mult = track["equity"]/INIT_EQUITY
    bm_mult = track["bench"]/INIT_EQUITY
    rel = eq_mult - bm_mult
    ax3.plot(track.index, eq_mult, label="Strategy")
    ax3.plot(track.index, bm_mult, label="Benchmark")
    ax3.plot(track.index, rel, label="Relative")
    ax3.legend(); ax3.grid(True, alpha=0.3)
    ax3.set_title("Comparable")

    # 4) Long / Flat / Short 累積進場次數線圖（你要的非水平）
    ax4 = fig.add_subplot(gs[1,0])
    pos = pos_series.reindex(track.index).fillna(0.0)
    sign_now  = np.sign(pos.values)
    sign_prev = np.sign(np.r_[0.0, pos.values[:-1]])
    long_entry  = ((sign_prev <= 0) & (sign_now > 0)).astype(int)   # 進多
    flat_entry  = ((sign_prev != 0) & (sign_now == 0)).astype(int)  # 轉空手
    short_entry = ((sign_prev >= 0) & (sign_now < 0)).astype(int)   # 進空
    long_cum  = np.cumsum(long_entry)
    flat_cum  = np.cumsum(flat_entry)
    short_cum = np.cumsum(short_entry)
    ax4.plot(pos.index, long_cum,  linewidth=1.2, label=f"Long ({int(long_cum[-1])})")
    ax4.plot(pos.index, flat_cum,  linewidth=1.2, label=f"Flat ({int(flat_cum[-1])})")
    ax4.plot(pos.index, short_cum, linewidth=1.2, label=f"Short ({int(short_cum[-1])})")
    ax4.set_title("Entry Count (Cumulative)")
    ax4.set_ylabel("Count")
    ax4.grid(True, alpha=0.3)
    ax4.legend(loc="upper left")

    # 5) Turnover（|Δpos|）
    ax5 = fig.add_subplot(gs[1,1])
    tv = turnover_series.reindex(track.index).fillna(0.0)
    ax5.plot(tv.index, tv.values, linewidth=0.8)
    ax5.set_title(f"Turnover (mean={tv.mean():.4f})")
    ax5.grid(True, alpha=0.3)

    # 6) Drawdown
    ax6 = fig.add_subplot(gs[1,2])
    dd, mdd = drawdown_curve(track["equity"])
    ax6.fill_between(track.index, dd, 0.0, alpha=0.6)
    ax6.set_title(f"Drawdown (Max {mdd:.2%})")
    ax6.grid(True, alpha=0.3)

    fig.tight_layout(); fig.savefig(out_png, dpi=150); plt.close(fig)
    return out_png

# ========= PPT（1 KPI → 2 Equity → 3 六宮格 → 4 WF OOS） =========
def make_ppt(best_cfg: dict, best_kpi: dict, eq_png: str, panel_png: str, wf_rows: list,
             out_ppt: str, sample_info: str, grid_count: int, survivors_count: int):
    prs = Presentation(); blank = prs.slides.add_slide(prs.slide_layouts[6])

    # 1) KPI
    s1 = prs.slides[-1]
    t1 = s1.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(9), Inches(0.6)).text_frame
    t1.text = "KPI（全段 × 最佳參數）"; t1.paragraphs[0].font.size=Pt(28)
    b1 = s1.shapes.add_textbox(Inches(0.5), Inches(1.0), Inches(5.6), Inches(5.2)).text_frame

    k = best_kpi
    lines = [
        sample_info,
        f"Grid：{grid_count:,}  | Stage-1 存活：{survivors_count:,}",
        f"成本模型：單邊 價格×{COST_RATE:.5f}",
        f"初始資金：{k['initial_equity']:.0f}",
        f"期末資金：{k['terminal_equity']:.0f}",
        f"總報酬：{k['total_return']:.2%}",
        f"CAGR：{(0 if pd.isna(k['cagr']) else k['cagr']):.2%}",
        f"年化波動：{(0 if pd.isna(k['ann_vol']) else k['ann_vol']):.2%}",
        f"Sharpe：{(0 if pd.isna(k['sharpe']) else k['sharpe']):.2f}",
        f"Sortino：{(0 if pd.isna(k['sortino']) else k['sortino']):.2f}",
        f"Calmar：{(0 if pd.isna(k['calmar']) else k['calmar']):.2f}",
        f"CVaR(95%)：{(0 if pd.isna(k['cvar_95']) else k['cvar_95']):.4f}",
        f"最大回撤：{k['max_drawdown']:.2%}",
        f"Profit Factor：{(0 if pd.isna(k['profit_factor']) else k['profit_factor']):.2f}",
        f"Up Capture：{(0 if pd.isna(k['up_capture']) else k['up_capture']):.2f}",
        f"Down Capture：{(0 if pd.isna(k['down_capture']) else k['down_capture']):.2f}",
        f"交易次數：{k['n_trades']}",
        f"勝率：{k['win_rate']:.2%}",
        f"Turnover(mean)：{(0 if pd.isna(k['turnover_mean']) else k['turnover_mean']):.4f}",
        "最佳參數：",
        json.dumps(best_cfg, ensure_ascii=False)
    ]
    # 第一段文字塞入段落0，其餘用 add_paragraph
    if lines:
        b1.text = lines[0]
        b1.paragraphs[0].font.size = Pt(16)
        for line in lines[1:]:
            p = b1.add_paragraph(); p.text=line; p.font.size=Pt(16)

    # 2) Equity（大圖）
    s2 = prs.slides.add_slide(prs.slide_layouts[6])
    s2.shapes.add_picture(eq_png, Inches(0.6), Inches(0.6), width=Inches(9.2))

    # 3) 六宮格
    s3 = prs.slides.add_slide(prs.slide_layouts[6])
    s3.shapes.add_picture(panel_png, Inches(0.6), Inches(0.6), width=Inches(9.2))

    # 4) WF OOS
    s4 = prs.slides.add_slide(prs.slide_layouts[6])
    t4 = s4.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(9), Inches(0.6)).text_frame
    t4.text = "WF OOS 指標（最佳參數，每段）"; t4.paragraphs[0].font.size=Pt(28)
    tb = s4.shapes.add_textbox(Inches(0.5), Inches(1.0), Inches(9), Inches(5)).text_frame
    hdr = tb.add_paragraph(); hdr.text = "段 | Sharpe | CAGR | Calmar | WinRate | Score"
    hdr.font.bold=True; hdr.font.size=Pt(16)
    if wf_rows:
        avg = float(np.mean([r["score"] for r in wf_rows]))
        for r in wf_rows:
            p = tb.add_paragraph()
            p.text = f"{r['i']:02d} | {r['sharpe']:.2f} | {r['cagr']:.2%} | {r['calmar']:.2f} | {r['win_rate']:.2%} | {r['score']:.3f}"
            p.font.size=Pt(14)
        p = tb.add_paragraph(); p.text = f"Average Score: {avg:.3f}"
        p.font.size=Pt(16); p.font.bold=True

    prs.save(out_ppt); return out_ppt

# ========= Grid 與主流程 =========
def grid_size(grid=GRID):
    n=1
    for v in grid.values(): n*=len(v)
    return n

def all_cfgs(grid=GRID):
    from itertools import product
    keys = list(grid.keys()); vals = [grid[k] for k in keys]
    for tup in product(*vals):
        yield dict(zip(keys, tup))

def full_pipeline(df):
    GRID_COUNT = grid_size(GRID)
    assert GRID_COUNT == 18432, f"Grid 組數錯誤：{GRID_COUNT}（應為 18432）"

    # Stage-1：全段粗篩
    survivors = []
    for cfg in tqdm(list(all_cfgs(GRID)), total=GRID_COUNT, desc="Stage-1 全段粗篩", unit="組"):
        kpi, *_ = run_strategy(df, cfg)
        if pass_stage1(kpi):
            survivors.append(cfg)

    print(f"[INFO] Stage-1 存活：{len(survivors):,} / {GRID_COUNT:,}", flush=True)

    # Stage-2：WF 打分
    best_cfg, best_score, best_rows = None, -1e9, []
    for cfg in tqdm(survivors, desc="Stage-2 WF 打分", unit="cfg"):
        rows=[]
        for i,(tr_df,te_df) in enumerate(wf_splits(df),1):
            if len(tr_df)<100 or len(te_df)<50: continue
            k_te, *_ = run_strategy(te_df, cfg)
            sc = score_from_kpi(k_te)
            rows.append(dict(i=i,
                sharpe=0 if pd.isna(k_te['sharpe']) else k_te['sharpe'],
                cagr=0 if pd.isna(k_te['cagr']) else k_te['cagr'],
                calmar=0 if pd.isna(k_te['calmar']) else k_te['calmar'],
                win_rate=k_te['win_rate'],
                score=sc))
        if not rows: continue
        avg = float(np.mean([r["score"] for r in rows]))
        if avg>best_score:
            best_score = avg; best_cfg = cfg; best_rows = rows

    return best_cfg, best_rows, GRID_COUNT, len(survivors)

def main():
    print("[BOOT] 正常版：全掃 Grid → 粗篩 → WF 打分 → 輸出 PPT", flush=True)
    df = read_teacher_bundle()
    sample_info = f"樣本期間：{df.index.min().date()} ~ {df.index.max().date()}  天數：{len(df):,}"

    best_cfg, wf_rows, GRID_COUNT, SURV_COUNT = full_pipeline(df)
    if best_cfg is None:
        raise RuntimeError("WF 無存活結果，請檢查門檻或樣本。")

    # 用最佳參數跑全段 → KPI / 圖 / PPT
    best_kpi, best_track, strat_ret, bench_ret, dpos, pos = run_strategy(df, best_cfg)

    eq_png    = "equity_best.png"
    panel_png = "panel_best.png"
    plot_equity(best_track, eq_png)
    plot_panel(df, best_track, best_kpi, dpos, pos, panel_png)

    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    pptx = f"TAIEX_WF_Scorecard_{ts}.pptx"

    with open("BestConfig.json","w",encoding="utf-8") as f:
        json.dump(best_cfg, f, ensure_ascii=False, indent=2)
    with open("BestMetrics.json","w",encoding="utf-8") as f:
        json.dump(best_kpi, f, ensure_ascii=False, indent=2)

    make_ppt(best_cfg, best_kpi, eq_png, panel_png, wf_rows, pptx, sample_info, GRID_COUNT, SURV_COUNT)

    # 終端摘要
    print("[DONE] 最佳參數：", json.dumps(best_cfg, ensure_ascii=False), flush=True)
    pick = {k: best_kpi[k] for k in [
        "initial_equity","terminal_equity","total_return","cagr",
        "sharpe","sortino","calmar","cvar_95","max_drawdown",
        "n_trades","win_rate","up_capture","down_capture","turnover_mean"
    ]}
    print("[KPI]：", json.dumps(pick, ensure_ascii=False), flush=True)
    print("[輸出]：", eq_png, panel_png, pptx, flush=True)

if __name__ == "__main__":
    main()
